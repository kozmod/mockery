{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mockery","text":"<p>Mockery is a project that creates mock implementations of Golang interfaces. The mocks generated in this project are based off of the github.com/stretchr/testify suite of testing packages.</p> <p> </p>"},{"location":"#why-mockery","title":"Why mockery?","text":"<p>When you have an interface like this:</p> db.go<pre><code>type DB interface {\nGet(val string) string\n}\n</code></pre> <p>and a function that takes this interface:</p> db_getter.go<pre><code>func getFromDB(db DB) string {\nreturn db.Get(\"ice cream\")\n}\n</code></pre> <p>You can test <code>getFromDB</code> by either instantiating a testing database, or you can simply create a mock implementation of <code>DB</code> using mockery. Mockery can autogenerate a mock implementation that allows us to define assertions on how the mock was used, what to return, and other useful tidbits. We can add a <code>//go:generate</code> directive above our interface:</p> db.go<pre><code>//go:generate mockery --name DB\ntype DB interface {\nGet(val string) string\n}\n</code></pre> .mockery.yaml<pre><code>inpackage: True # (1)!\nwith-expecter: True # (2)!\ntestonly: True # (3)!\n</code></pre> <ol> <li>Generate our mocks next to the original interface</li> <li>Create expecter methods</li> <li>Append <code>_test.go</code> to the filename so the mock object is not packaged </li> </ol> Bash<pre><code>$ go generate  05 Mar 23 21:49 CST INF Starting mockery dry-run=false version=v2.20.0\n05 Mar 23 21:49 CST INF Using config: .mockery.yaml dry-run=false version=v2.20.0\n05 Mar 23 21:49 CST INF Walking dry-run=false version=v2.20.0\n05 Mar 23 21:49 CST INF Generating mock dry-run=false interface=DB qualified-name=github.com/vektra/mockery/v2/pkg/fixtures/example_project version=v2.20.0\n</code></pre> <p>We can then use the mock object in a test:</p> db_getter_test.go<pre><code>import (\n\"testing\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc Test_getFromDB(t *testing.T) {\nmockDB := NewMockDB(t)\nmockDB.EXPECT().Get(\"ice cream\").Return(\"chocolate\").Once()\nflavor := getFromDB(mockDB)\nassert.Equal(t, \"chocolate\", flavor)\n}\n</code></pre>"},{"location":"#why-use-mockery-over-gomock","title":"Why use mockery over gomock?","text":"<ol> <li>mockery provides a much more user-friendly API and is less confusing to use</li> <li>mockery utilizes <code>testify</code> which is a robust and highly feature-rich testing framework</li> <li>mockery has rich configuration options that allow fine-grained control over how your mocks are generated</li> <li>mockery's CLI is more robust, user-friendly, and provides many more options</li> <li>mockery supports generics (this may no longer be an advantage if/when gomock supports generics)</li> </ol>"},{"location":"#who-uses-mockery","title":"Who uses mockery?","text":"<p> grafana \u00b7  Google Skia \u00b7 Hashicorp \u00b7  Google Skyzkaller \u00b7  Uber Cadence \u00b7 Jaeger \u00b7 Splunk \u00b7 Ignite CLI \u00b7 Tendermint \u00b7 Datadog</p> <p>Get Started</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This changelog describes major feature additions. Please view the <code>releases</code> page for more details on commits and minor changes.</p>"},{"location":"changelog/#v2290-template-functions","title":"<code>v2.29.0</code> template functions","text":"<p>This release adds a large number of template functions available for use in the <code>packages</code> templating engine.</p>"},{"location":"changelog/#v2250-recursive-config","title":"<code>v2.25.0</code> <code>recursive</code> config","text":"<p>The <code>recursive</code> parameter allows mockery to dynamically discover sub-packages when using the <code>packages</code> config.</p>"},{"location":"changelog/#v2240-exclude-config","title":"<code>v2.24.0</code> <code>exclude</code> config","text":"<p>The <code>exclude</code> parameter allows you to define subpaths to ignore. This is currently only compatible when using non-<code>packages</code> config.</p>"},{"location":"changelog/#v2230-replace-types","title":"<code>v2.23.0</code> Replace Types","text":"<p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p>"},{"location":"changelog/#v2210-packages-configuration","title":"<code>v2.21.0</code>: <code>packages</code> configuration","text":"<p>In this version we release the <code>packages</code> configuration section. This new parameter allows defining specific packages to generate mocks for, while also giving fine-grained control over which interfaces are mocked, where they are located, and how they are configured. Details are provided here.</p> <p>Community input is desired before we consider deprecations of dynamic walking (via <code>all: True</code>): https://github.com/vektra/mockery/discussions/549</p>"},{"location":"changelog/#v2200-improved-return-value-functions","title":"<code>v2.20.0</code>: Improved Return Value Functions","text":"<p>Return value functions that return an entire method's return value signature can now be provided.</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) (string, error) {\nreturn s, nil\n}\n)\n</code></pre> <p>You may still use the old way where one function is provided for each return value:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) string {\nreturn s\n},\nfunc(ctx context.Context, s string) error {\nreturn nil\n},\n)\n</code></pre>"},{"location":"changelog/#2190-inpackage-suffix-option","title":"<code>2.19.0</code>: <code>inpackage-suffix</code> option","text":"<p>When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks</p>"},{"location":"changelog/#v2160-config-search-path","title":"<code>v2.16.0</code>: Config Search Path","text":"<p>Mockery will iteratively search every directory from the current working directory up to the root path for a <code>.mockery.yaml</code> file, if one is not explicitly provided.</p>"},{"location":"changelog/#v2130-generics-support","title":"<code>v2.13.0</code>: Generics support","text":"<p>Mocks are now capable of supporting Golang generics.</p>"},{"location":"changelog/#v2110-mock-constructors","title":"<code>v2.11.0</code>: Mock constructors","text":"<p>Mockery v2.11 introduces constructors for all mocks. This makes instantiation and mock registration a bit easier and less error-prone (you won't have to worry about forgetting the <code>AssertExpectations</code> method call anymore).</p> <p>Before v2.11: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>After v2.11: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically - The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method. - The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</p>"},{"location":"changelog/#v2100-expecter-structs","title":"<code>v2.10.0</code>: Expecter Structs","text":"<p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\nGet(path string) (string, error)\n}\n</code></pre></p> <p>You can use the type-safe expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\nrequesterMock.EXPECT().\nGet(mock.Anything).\nRun(func(path string) { fmt.Println(path, \"was called\") }).\n// Can still use return functions by getting the embedded mock.Call\nCall.Return(func(path string) string { return \"result for \" + path }, nil)\n</code></pre></p>"},{"location":"changelog/#v200-major-update","title":"<code>v2.0.0</code>: Major Update","text":"<p>This is the first major update of mockery. Version 2 brings a handful of improvements to mockery:</p> <ul> <li>Structured and pretty console logging</li> <li>CLI now switches over to sp13/cobra</li> <li>Use of viper configuration parsing. You can now use a .mockery.yaml config file in your repository</li> <li>Various CI fixes and improvements</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>mockery uses spf13/viper under the hood for its configuration parsing. It is bound to three different configuration sources, in order of decreasing precedence:</p> <ol> <li>Command line</li> <li>Environment variables</li> <li>Configuration file</li> </ol> <p>If a parameter is named <code>with-expecter</code> and we want a value of <code>True</code>, then these are the formats for each source:</p> source value command line <code>--with-expecter=true</code> Environment variable <code>MOCKERY_WITH_EXPECTER=True</code> yaml <code>with-expecter: True</code>"},{"location":"configuration/#recommended-basic-config","title":"Recommended Basic Config","text":"<p>Copy the recommended basic configuration to a file called <code>.mockery.yaml</code> at the top-level of your repo:</p> .mockery.yaml<pre><code>inpackage: True\ntestonly: True\nwith-expecter: True\nkeeptree: False\n</code></pre> <p>mockery will search upwards from your current-working-directory up to the root path, so the same configuration should be able to follow you within your project.</p>"},{"location":"configuration/#parameter-descriptions","title":"Parameter Descriptions","text":""},{"location":"configuration/#non-packages","title":"non-<code>packages</code>","text":"<p>These are the configuration options available when using the legacy, non-<code>packages</code> configuration semantics.</p> <p>non-<code>packages</code> config</p> name description <code>all</code> It's common for a big package to have a lot of interfaces, so mockery provides <code>all</code>. This option will tell mockery to scan all files under the directory named by <code>--dir</code> (\".\" by default) and generates mocks for any interfaces it finds. This option implies <code>recursive: True</code>. <code>boilerplate-file</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>case</code> mockery generates files using the casing of the original interface name.  This can be modified by specifying <code>case: underscore</code> to format the generated file name using underscore casing. <code>exclude</code> This parameter is a list of strings representing path prefixes that should be excluded from mock generation. <code>exported</code> Use <code>exported: True</code> to generate public mocks for private interfaces. <code>filename</code> Use the <code>filename</code> and <code>structname</code> to override the default generated file and struct name. These options are only compatible with non-regular expressions in <code>name</code>, where only one mock is generated. <code>inpackage-suffix</code> When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks <code>inpackage</code> and <code>keeptree</code> For some complex repositories, there could be multiple interfaces with the same name but in different packages. In that case, <code>inpackage</code> allows generating the mocked interfaces directly in the package that it mocks. In the case you don't want to generate the mocks into the package but want to keep a similar structure, use the option <code>keeptree</code>. <code>name</code> The <code>name</code> option takes either the name or matching regular expression of the interface to generate mock(s) for. <code>output</code> mockery always generates files with the package <code>mocks</code> to keep things clean and simple. You can control which mocks directory is used by using <code>output</code>, which defaults to <code>./mocks</code>. <code>outpkg</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>print</code> Use <code>print: True</code> to have the resulting code printed out instead of written to disk. <code>recursive</code> Use the <code>recursive</code> option to search subdirectories for the interface(s). This option is only compatible with <code>name</code>. The <code>all</code> option implies <code>recursive: True</code>. <code>replace-type source=destination</code> Replaces aliases, packages and/or types during generation. <code>testonly</code> Prepend every mock file with <code>_test.go</code>. This is useful in cases where you are generating mocks <code>inpackage</code> but don't want the mocks to be visible to code outside of tests. <code>with-expecter</code> Use <code>with-expecter: True</code> to generate <code>EXPECT()</code> methods for your mocks. This is the preferred way to setup your mocks."},{"location":"configuration/#packages-config","title":"<code>packages</code> config","text":"<p>These are the config options when using the <code>packages</code> config option. Use of the <code>packages</code> config semantics puts mockery into a completely different code path. Config variables may have changed meanings or have been substracted entirely, compared to the non-<code>packages</code> config.</p> <p>Please see the features section for more details on how <code>packages</code> works, including some example configuration.</p> <p><code>packages</code> config</p> name templated default description <code>all</code> <code>false</code> Generate all interfaces for the specified packages. <code>boilerplate-file</code> <code>\"\"</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>config</code> <code>\"\"</code> Set the location of the mockery config file. <code>dir</code> <code>\"mocks/{{.PackagePath}}\"</code> The directory where the mock file will be outputted to. <code>disable-config-search</code> <code>false</code> Disable searching for configuration files <code>disable-version-string</code> <code>false</code> Disable the version string in the generated mock files. <code>dry-run</code> <code>false</code> Print the actions that would be taken, but don't perform the actions. <code>filename</code> <code>\"mock_{{.InterfaceName}}.go\"</code> The name of the file the mock will reside in. <code>inpackage</code> <code>false</code> When generating mocks alongside the original interfaces, you must specify <code>inpackage: True</code> to inform mockery that the mock is being placed in the same package as the original interface. <code>mockname</code> <code>\"Mock{{.InterfaceName}}\"</code> The name of the generated mock. <code>outpkg</code> <code>\"{{.PackageName}}\"</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>log-level</code> <code>\"info\"</code> Set the level of the logger <code>packages</code> <code>null</code> A dictionary containing configuration describing the packages and interfaces to generate mocks for. <code>print</code> <code>false</code> Use <code>print: True</code> to have the resulting code printed out instead of written to disk. <code>recursive</code> <code>false</code> When set to <code>true</code> on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. <code>tags</code> <code>\"\"</code> Set the build tags of the generated mocks. <code>with-expecter</code> <code>true</code> Use <code>with-expecter: True</code> to generate <code>EXPECT()</code> methods for your mocks. This is the preferred way to setup your mocks. <code>replace-type</code> <code>null</code> Replaces aliases, packages and/or types during generation."},{"location":"configuration/#template-variables","title":"Template Variables","text":"<p>Note</p> <p>Templated variables are only available when using the <code>packages</code> config feature.</p> <p>Variables that are marked as being templated are capable of using mockery-provided template parameters.</p> name description InterfaceDir The directory path of the original interface being mocked. This can be used as <code>dir: \"{{.InterfaceDir}}\"</code> to place your mocks adjacent to the original interface. This should not be used for external interfaces. InterfaceDirRelative The directory path of the original interface being mocked, relative to the current working directory. If the path cannot be made relative to the current working directory, this variable will be set equal to <code>PackagePath</code> InterfaceName The name of the original interface being mocked InterfaceNameCamel Converts a string <code>interface_name</code> to <code>InterfaceName</code> InterfaceNameLowerCamel Converts <code>InterfaceName</code> to <code>interfaceName</code> InterfaceNameSnake Converts <code>InterfaceName</code> to <code>interface_name</code> Mock A string that is <code>Mock</code> if the interface is exported, or <code>mock</code> if it is not exported. Useful when setting the name of your mock to something like: <code>mockname: \"{{.Mock}}{{.InterfaceName}}\"</code> This way, the mock name will retain the exported-ness of the original interface. MockName The name of the mock that will be generated. Note that this is simply the <code>mockname</code> configuration variable PackageName The name of the package from the original interface PackagePath The fully qualified package path of the original interface"},{"location":"configuration/#template-functions","title":"Template functions","text":"<p>Note</p> <p>Templated functions are only available when using the <code>packages</code> config feature.</p> <p>Template functions allow you to inspect and manipulate template variables.</p> <p>All template functions are calling native Go functions under the hood, so signatures and return values matches the Go functions you are probably already familiar with.</p> <p>To learn more about the templating syntax, please see the Go <code>text/template</code> documentation</p> <ul> <li><code>contains</code> string substr</li> <li><code>hasPrefix</code> string prefix</li> <li><code>hasSuffix</code> string suffix</li> <li><code>join</code> elems sep</li> <li><code>replace</code> string old new n</li> <li><code>replaceAll</code> string old new</li> <li><code>split</code> string sep</li> <li><code>splitAfter</code> string sep</li> <li><code>splitAfterN</code> string sep n</li> <li><code>trim</code> string cutset</li> <li><code>trimLeft</code> string cutset</li> <li><code>trimPrefix</code> string prefix</li> <li><code>trimRight</code> string cutset</li> <li><code>trimSpace</code> string</li> <li><code>trimSuffix</code> string suffix</li> <li><code>matchString</code> pattern</li> <li><code>quoteMeta</code> string</li> <li><code>base</code> string</li> <li><code>clean</code> string</li> <li><code>dir</code> string</li> <li><code>expandEnv</code> string</li> <li><code>getenv</code> string</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#simple-case","title":"Simple case","text":"<p>Given this interface:</p> string.go<pre><code>package example_project\n//go:generate mockery --name Stringer\ntype Stringer interface {\nString() string\n}\n</code></pre> <p>Run: <code>go generate</code> (using the recommended config) and the the file <code>mock_Stringer_test.go</code> will be generated. You can now use this mock to create assertions and expectations.</p> string_test.go<pre><code>package example_project\nimport (\n\"testing\"\n\"github.com/stretchr/testify/assert\"\n)\nfunc Foo(s Stringer) string {\nreturn s.String()\n}\nfunc TestString(t *testing.T) {\nmockStringer := NewMockStringer(t)\nmockStringer.EXPECT().String().Return(\"mockery\")\nassert.Equal(t, \"mockery\", Foo(mockStringer))\n}\n</code></pre> <p>Note that in combination with using the mock's constructor and the <code>.EXPECT()</code> directives, your test will automatically fail if the expected call is not made.</p>"},{"location":"examples/#function-type-case","title":"Function type case","text":"<p>Given this is in <code>send.go</code></p> Go<pre><code>package test\ntype SendFunc func(data string) (int, error)\n</code></pre> <p>Run: <code>mockery --name=SendFunc</code> and the following will be output:</p> mock_SendFunc_test.go<pre><code>package mocks\nimport (\n\"github.com/stretchr/testify/mock\"\ntesting \"testing\"\n)\ntype SendFunc struct {\nmock.Mock\n}\nfunc (_m *SendFunc) Execute(data string) (int, error) {\nret := _m.Called(data)\nvar r0 int\nif rf, ok := ret.Get(0).(func(string) int); ok {\nr0 = rf(data)\n} else {\nr0 = ret.Get(0).(int)\n}\nvar r1 error\nif rf, ok := ret.Get(1).(func(string) error); ok {\nr1 = rf(data)\n} else {\nr1 = ret.Error(1)\n}\nreturn r0, r1\n}\n// NewSendFunc creates a new instance of SendFunc. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewSendFunc(t testing.TB) *SendFunc {\nmock := &amp;SendFunc{}\nmock.Mock.Test(t)\nt.Cleanup(func() { mock.AssertExpectations(t) })\nreturn mock\n}\n</code></pre>"},{"location":"examples/#return-value-provider-functions","title":"Return Value Provider Functions","text":"<p>If your tests need access to the arguments to calculate the return values, set the return value to a function that takes the method's arguments as its own arguments and returns the return value. For example, given this interface:</p> Go<pre><code>package test\ntype Proxy interface {\npassthrough(ctx context.Context, s string) string\n}\n</code></pre> <p>The argument can be passed through as the return value:</p> Go<pre><code>import . \"github.com/stretchr/testify/mock\"\nproxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(func(ctx context.Context, s string) string {\nreturn s\n})\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#replace-types","title":"Replace Types","text":"<p> v2.23.0</p> <p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p> <p>The format of the parameter is:</p> <p><code>originalPackagePath.originalTypeName=newPackageName:newPackagePath.newTypeName</code></p> <p>For example:</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz=baz:github.com/vektra/mockery/v2/baz.Baz\n</code></pre> <p>This will replace any imported named <code>\"github.com/vektra/mockery/v2/baz/internal/foo\"</code> with <code>baz \"github.com/vektra/mockery/v2/baz\"</code>. The alias is defined with <code>:</code> before the package name. Also, the <code>InternalBaz</code> type that comes from this package will be renamed to <code>baz.Baz</code>.</p> <p>This next example fixes a common problem of type aliases that point to an internal package.</p> <p><code>cloud.google.com/go/pubsub.Message</code> is a type alias defined like this:</p> Go<pre><code>import (\nipubsub \"cloud.google.com/go/internal/pubsub\"\n)\ntype Message = ipubsub.Message\n</code></pre> <p>The Go parser that mockery uses doesn't provide a way to detect this alias and sends the application the package and type name of the type in the internal package, which will not work.</p> <p>We can use <code>replace-type</code> with only the package part to replace any import of <code>cloud.google.com/go/internal/pubsub</code> to <code>cloud.google.com/go/pubsub</code>. We don't need to change the alias or type name in this case, because they are <code>pubsub</code> and <code>Message</code> in both cases.</p> Bash<pre><code>mockery --replace-type cloud.google.com/go/internal/pubsub=cloud.google.com/go/pubsub\n</code></pre> <p>Original source:</p> Go<pre><code>import (\n\"cloud.google.com/go/pubsub\"\n)\ntype Handler struct {\nHandleMessage(m pubsub.Message) error\n}\n</code></pre> <p>Invalid mock generated without this parameter (points to an <code>internal</code> folder):</p> Go<pre><code>import (\nmock \"github.com/stretchr/testify/mock\"\npubsub \"cloud.google.com/go/internal/pubsub\"\n)\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n// ...\nreturn nil\n}\n</code></pre> <p>Correct mock generated with this parameter.</p> Go<pre><code>import (\nmock \"github.com/stretchr/testify/mock\"\npubsub \"cloud.google.com/go/pubsub\"\n)\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n// ...\nreturn nil\n}\n</code></pre>"},{"location":"features/#packages-configuration","title":"<code>packages</code> configuration","text":"<p> v2.21.0 \u00b7  Beta Feature</p> <p>Warning</p> <p>This feature is considered beta. The feature set has been solidifed, but we are asking users to beta-test for any bugs. Use at your own risk. This warning will be updated as this feature matures.</p> <p>Info</p> <p>See the Migration Docs on how to migrate to this new feature.</p> <p>Mockery has a configuration parameter called <code>packages</code>. In this config section, you define the packages and the intefaces you want mocks generated for. The packages can be any arbitrary package, either your own project or anything within the Go ecosystem. You may provide package-level or interface-level overrides to the default config you provide.</p> <p>Usage of the <code>packages</code> config section is desirable for mutiple reasons:</p> <ol> <li>Up to 5x increase in mock generation speed over the legacy method</li> <li>Granular control over interface generation, location, and file names</li> <li>Singular location for all config, instead of spread around by <code>//go:generate</code> statements</li> <li>Clean, easy to understand.</li> </ol>"},{"location":"features/#examples","title":"Examples","text":"<p>Here is an example configuration set:</p> YAML<pre><code>with-expecter: True\npackages:\ngithub.com/vektra/mockery/v2/pkg: # (1)!\ninterfaces:\nTypesPackage:\nRequesterVariadic:\nconfig: # (2)!\nwith-expecter: False configs:\n- mockname: MockRequesterVariadicOneArgument\nunroll-variadic: False\n- mockname: MockRequesterVariadic\nio:\nconfig:\nall: True # (3)!\ninterfaces:\nWriter:\nconfig:\nwith-expecter: False # (4)!\n</code></pre> <ol> <li>For this package, we provide no package-level config (which means we inherit the deafults at the top-level). Since our default of <code>all:</code> is <code>False</code>, mockery will only generate the interfaces we specify. We tell it which interface to generate by using the <code>interfaces</code> section and specifying an empty map, one for each interface.</li> <li>There might be cases where you want multiple mocks generated from the same interface. To do this, you can define a default <code>config</code> section for the interface, and further <code>configs</code> (plural) section, one for each mock. You must specify a <code>mockname</code> for the mocks in this section to differentiate them.</li> <li>This is telling mockery to generate all interfaces in the <code>io</code> package.</li> <li>We can provide interface-specifc overrides to the generation config.</li> </ol>"},{"location":"features/#templated-variables","title":"Templated variables","text":"<p>Note</p> <p>Templated variables are only available when using the <code>packages</code> config feature.</p> <p>Included with this feature is the ability to use templated strings for various configuration options. This is useful to define where your mocks are placed and how to name them. You can view the template variables available in the Configuration section of the docs.</p>"},{"location":"features/#layouts","title":"Layouts","text":"<p>Using different configuration parameters, we can deploy our mocks on-disk in various ways. These are some common layouts:</p> <p>layouts</p> defaultsadjacent to interface YAML<pre><code>filename: \"mock_{{.InterfaceName}}.go\"\ndir: \"mocks/{{.PackagePath}}\"\nmockname: \"Mock{{.InterfaceName}}\"\noutpkg: \"{{.PackageName}}\"\n</code></pre> <p>If these variables aren't specified, the above values will be applied to the config options. This strategy places your mocks into a separate <code>mocks/</code> directory.</p> <p>Interface Description</p> name value <code>InterfaceName</code> <code>MyDatabase</code> <code>PackagePath</code> <code>github.com/user/project/pkgName</code> <code>PackageName</code> <code>pkgName</code> <p>Output</p> <p>The mock will be generated at:</p> Text Only<pre><code>mocks/github.com/user/project/pkgName/mock_MyDatabase.go\n</code></pre> <p>The mock file will look like:</p> Go<pre><code>package pkgName\nimport mock \"github.com/stretchr/testify/mock\"\ntype MockMyDatabase struct {\nmock.Mock\n}\n</code></pre> <p>Warning</p> <p>Mockery does not protect against modifying original source code. Do not generate mocks using this config with uncommitted code changes.</p> YAML<pre><code>filename: \"mock_{{.InterfaceName}}.go\"\ndir: \"{{.InterfaceDir}}\"\nmockname: \"Mock{{.InterfaceName}}\"\noutpkg: \"{{.PackageName}}\"\ninpackage: True\n</code></pre> <p>Instead of the mocks being generated in a different folder, you may elect to generate the mocks alongside the original interface in your package. This may be the way most people define their configs, as it removes circular import issues that can happen with the default config.</p> <p>For example, the mock might be generated along side the original source file like this:</p> Text Only<pre><code>./path/to/pkg/db.go\n./path/to/pkg/mock_MyDatabase.go\n</code></pre> <p>Interface Description</p> name value <code>InterfaceName</code> <code>MyDatabase</code> <code>PackagePath</code> <code>github.com/user/project/path/to/pkg</code> <code>PackagePathRelative</code> <code>path/to/pkg</code> <code>PackageName</code> <code>pkgName</code> <code>SourceFile</code> <code>./path/to/pkg/db.go</code> <p>Output</p> <p>Mock file will be generated at:</p> Text Only<pre><code>./path/to/pkg/mock_MyDatabase.go\n</code></pre> <p>The mock file will look like:</p> Go<pre><code>package pkgName\nimport mock \"github.com/stretchr/testify/mock\"\ntype MockMyDatabase struct {\nmock.Mock\n}\n</code></pre>"},{"location":"features/#recursive-package-discovery","title":"Recursive package discovery","text":"<p> v2.25.0</p> <p>When <code>recursive: true</code> is set on a particular package:</p> YAML<pre><code>packages:\ngithub.com/user/project:\nconfig:\nrecursive: true\nwith-expecter: true\n</code></pre> <p>mockery will dynamically discover all sub-packages within the specified package. This is done by calling <code>packages.Load</code> on the specified package, which induces Go to download the package from the internet (or simply your local project). Mockery then recursively discovers all sub-directories from the root package that also contain <code>.go</code> files and injects the respective package path into the config map as if you had specified them manually. As an example, your in-memory config map may end up looking like this:</p> YAML<pre><code>packages:\ngithub.com/user/project:\nconfig:\nrecursive: true\nwith-expecter: true\ngithub.com/user/project/subpkg1:\nconfig:\nrecursive: true\nwith-expecter: true\ngithub.com/user/project/subpkg2:\nconfig:\nrecursive: true\nwith-expecter: true\n</code></pre> <p>You can use the <code>showconfig</code> command to see the config mockery injects. The output of <code>showconfig</code> theoretically could be copy-pasted into your yaml file as it is semantically equivalent.</p> performance characteristics <p>The performance when using <code>recursive: true</code> may be worse than manually specifying all packages statically in the yaml file. This is because of the fact that mockery has to recursively walk the filesystem path that contains the package in question. It may unnecessarily walk down unrelated paths (for example, a Python virtual environment that is in the same path as your package). For this reason, it is recommended not to use <code>recursive: true</code> if it can be avoided.</p>"},{"location":"features/#mock-constructors","title":"Mock Constructors","text":"<p> v2.11.0</p> <p>All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits.</p> <p>Previously something like this would need to be done: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>Instead, you may simply use the constructor: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically - The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method. - The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</p>"},{"location":"features/#expecter-structs","title":"Expecter Structs","text":"<p> v2.10.0 \u00b7 <code>with-expecter: True</code></p> <p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\nGet(path string) (string, error)\n}\n</code></pre></p> <p>You can use the expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\n</code></pre></p> <p>A <code>RunAndReturn</code> method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call.</p> Go<pre><code>requesterMock.EXPECT().\nGet(mock.Anything).\nRunAndReturn(func(path string) string { fmt.Println(path, \"was called\")\nreturn \"result for \" + path\n})\n</code></pre> <p>Note</p> <p>Note that the types of the arguments on the <code>EXPECT</code> methods are <code>interface{}</code>, not the actual type of your interface. The reason for this is that you may want to pass <code>mock.Any</code> as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.</p>"},{"location":"features/#return-value-providers","title":"Return Value Providers","text":"<p> v2.20.0</p> <p>Return Value Providers can be used one of two ways.  You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to <code>Return</code>, or you may pass multiple values to <code>Return</code> (one for each return parameter of the mocked function.)  If you are using the second form, for each of the return values of the mocked function, <code>Return</code> needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of <code>passthrough</code> in the above example was instead <code>(string, error)</code> in the interface, <code>Return</code> would also need a second function argument to define the error value:</p> Go<pre><code>type Proxy interface {\npassthrough(ctx context.Context, s string) (string, error)\n}\n</code></pre> <p>First form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) (string, error) {\nreturn s, nil\n}\n)\n</code></pre> <p>Second form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\nfunc(ctx context.Context, s string) string {\nreturn s\n},\nfunc(ctx context.Context, s string) error {\nreturn nil\n},\n)\n</code></pre>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#github-release","title":"GitHub Release","text":"<p>recommended</p> <p>Visit the releases page to download one of the pre-built binaries for your platform.</p>"},{"location":"installation/#go-install","title":"go install","text":"<p>Supported, but not recommended: see wiki page and related discussions.</p> Text Only<pre><code>go install github.com/vektra/mockery/v2@v2.30.1\n</code></pre> <p>Warning</p> <p>Do not use <code>@latest</code> as this will pull from the latest, potentially untagged, commit on master.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>Use the Docker image</p> Text Only<pre><code>docker pull vektra/mockery\n</code></pre> <p>Generate all the mocks for your project:</p> Text Only<pre><code>docker run -v \"$PWD\":/src -w /src vektra/mockery --all\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>Install through brew</p> Text Only<pre><code>brew install mockery\nbrew upgrade mockery\n</code></pre>"},{"location":"migrating_to_packages/","title":"Migrating To Packages","text":"<p>The packages feature is a new configuration scheme that aims to simplify and improve a lot of legacy behavior. This will be the only way to generate mocks in v3. These docs outline general principals for migrating to the new scheme.</p>"},{"location":"migrating_to_packages/#background","title":"Background","text":"<p>mockery was built during the pre-module era of Golang. Much of its codebase and configuration syntax was designed around file-based operations. This model became highly inefficient once Golang migrated to module-based packages. The old configuration semantics also proved limiting -- many users introduced and requested feature additions to mockery to support esoteric use-cases. This proved to be a huge maintenance burden that existed solely because the configuration model could not flexibly describe all the situations users wanted. The <code>packages</code> semantics provides us a few highly desirable traits:</p> <ol> <li>Orders of magnitude performance increase, due to calling <code>packages.Load</code> once or twice for an entire project, versus once per file in the legacy semantics.</li> <li>Hierarchical configuration model that allows interface-specific config to be inherited from package-level config, which is inherited from defaults.</li> <li>Single configuration file that describes the entirety of mockery's behavior, instead of spread out by <code>//go: generate</code> statements.</li> <li>Extensive and flexible usage of a Golang string templating environment that allows users to dynamically specify parameter values.</li> </ol>"},{"location":"migrating_to_packages/#configuration-changes","title":"Configuration Changes","text":"<p>The existence of the <code>packages:</code> map in your configuration acts as a feature flag that enables the feature.</p> <p>The configuration parameters used in <code>packages</code> should be considered to have no relation to their meanings in the legacy scheme. It is recommended to wipe out all previous configuration and command-line parameters previously used.</p> <p>The configuration docs show the parameters that are available for use in the <code>packages</code> scheme. You should only use the parameters shown in this section. Mockery will not prevent you from using the legacy parameter set, but doing so will result in undefined behavior.</p> <p>All of the parameters in the config section can be specified at the top level of the config file, which serves as the default values. The <code>packages</code> config section defines package-specific config. See some exampes here.</p>"},{"location":"migrating_to_packages/#go-generate-directives","title":"<code>//go: generate</code> directives","text":"<p>Previously, the recommended way of generating mocks was to call <code>mockery</code> once per interface using <code>//go: generate</code>. Generating interface-specific mocks this way is no longer supported. You may still use <code>//go: generate</code> to call mockery, however it will generate all interfaces defined in your config file. There currently exists no semantics to specify the generation of specific interfaces from the command line (not because we reject the idea, but because it was not seen as a requirement for the initial iteration of <code>packages</code>).</p>"},{"location":"migrating_to_packages/#behavior-changes","title":"Behavior Changes","text":"<p>The legacy behavior iterated over every <code>.go</code> file in your project, called <code>packages.Load</code> to parse the syntax tree, and generated mocks for every interface found in the file. The new behavior instead simply grabs the list of packages to load from the config file, or in the case of <code>recursive: True</code>, walks the filesystem tree to discover the packages that exist (without actually parsing the files). Using this list, it calls <code>packages.Load</code> once with the list of packages that were discovered.</p>"},{"location":"migrating_to_packages/#filesystem-tree-layouts","title":"Filesystem Tree Layouts","text":"<p>The legacy config provided the <code>keeptree</code> parameter which, if <code>keeptree: True</code>, would place the mocks in the same package as your interfaces. Otherwise, it would place it in a separate directory.</p> <p>These two layouts are supported in the <code>packages</code> scheme. See the relevant docs here.</p>"},{"location":"notes/","title":"Frequently Asked Questions","text":""},{"location":"notes/#error-no-go-files-found-in-root-search-path","title":"error: <code>no go files found in root search path</code>","text":"<p>When using the <code>packages</code> feature, <code>recursive: true</code> and you have specified a package that contains no <code>*.go</code> files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata.</p> <p>The solution is to create a <code>.go</code> file in the package's path and add a <code>package [name]</code> directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata.</p> <p>Discussion</p>"},{"location":"notes/#internal-error-package-without-types-was-imported","title":"internal error: package without types was imported","text":"<p>https://github.com/vektra/mockery/issues/475</p> <p>This issue indicates an incompatability that exists with one of your cached Golang packages. The solution is to run <code>go clean -modcache</code>.</p> <p>This issue also happens when compiling from source, such as with <code>go install</code>. You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the <code>.tar.gz</code> binaries, or through <code>brew install</code>.</p>"},{"location":"notes/#multiple-expectations-with-identical-arguments","title":"Multiple Expectations With Identical Arguments","text":"<p>There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example we might want to test this behavior:</p> Go<pre><code>// Return \"foo\" on the first call\ngetter := NewGetter()\nassert(t, \"foo\", getter.Get(\"key\"))\n// Return \"bar\" on the second call\nassert(t, \"bar\", getter.Get(\"key\"))\n</code></pre> <p>This can be done by using the <code>.Once()</code>  method on the mock call expectation:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Once()\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Once()\n</code></pre> <p>Or you can identify an arbitrary number of times each value should be returned:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Times(4)\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Times(2)\n</code></pre> <p>Note that with proper Golang support in your IDE, all of the available methods are self-documented in auto-completion help contexts.</p>"},{"location":"notes/#variadic-arguments","title":"Variadic Arguments","text":"<p>Consider if we have a function <code>func Bar(message ...string) error</code>. A typical assertion might look like this:</p> Go<pre><code>func TestFoo(t *testing.T) {\nm := NewMockFoo(t)\nm.On(\"Bar\", \"hello\", \"world\").Return(nil)\n</code></pre> <p>We might also want to make an assertion that says \"any number of variadic arguments\":</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions:</p> <ol> <li>Any number of variadic arguments of any value</li> <li>A single variadic argument of any value</li> </ol> <p>This is fixed in #359 where you can provide <code>unroll-variadic: False</code> to get back to the old behavior. Thus, if you want to assert (1), you can then do:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>If you want to assert (2), you must set <code>unroll-variadic: True</code>. Then this assertion's intention will be modified to mean the second case:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>An upstream patch to <code>testify</code> is currently underway to allow passing <code>mock.Anything</code> directly to the variadic slice: https://github.com/stretchr/testify/pull/1348</p> <p>If this is merged, it would become possible to describe the above two cases respectively:</p> Go<pre><code>// case 1\nm.On(\"Bar\", mock.Anything).Return(nil)\n// case 2\nm.On(\"Bar\", []interface{}{mock.Anything}).Return(nil)\n</code></pre> <p>References:</p> <ul> <li>https://github.com/vektra/mockery/pull/359</li> <li>https://github.com/vektra/mockery/pull/123</li> <li>https://github.com/vektra/mockery/pull/550</li> <li>https://github.com/vektra/mockery/issues/541</li> </ul>"},{"location":"notes/#semantic-versioning","title":"Semantic Versioning","text":"<p>The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following:</p> <ol> <li>CLI arguments.</li> <li>Parsing of Golang code. New features in the Golang language will be supported in a backwards-compatible manner, except during major version bumps.</li> <li>Behavior of mock objects. Mock objects can be considered to be part of the public API.</li> <li>Behavior of mockery given a set of arguments.</li> </ol> <p>What the version does not track:</p> <ol> <li>The interfaces, objects, methods etc. in the vektra/mockery package.</li> <li>Compatibility of <code>go get</code>-ing mockery with new or old versions of Golang.</li> </ol>"},{"location":"notes/#mocking-interfaces-in-main","title":"Mocking interfaces in <code>main</code>","text":"<p>When your interfaces are in the main package, you should supply the <code>--inpackage</code> flag. This will generate mocks in the same package as the target code, avoiding import issues.</p>"},{"location":"notes/#mockery-fails-to-run-when-mockery_version-environment-variable-is-set","title":"mockery fails to run when <code>MOCKERY_VERSION</code> environment variable is set","text":"<p>This issue was first highlighted in this GitHub issue.</p> <p>mockery uses the viper package for configuration mapping and parsing. Viper is set to automatically search for all config variables specified in its config struct. One of the config variables is named <code>version</code>, which gets mapped to an environment variable called <code>MOCKERY_VERSION</code>. If you set this environment variable, mockery attempts to parse it into the <code>version</code> bool config.</p> <p>This is an unintended side-effect of how our config parsing is set up. The solution is to rename your environment variable to something other than <code>MOCKERY_VERSION</code>.</p>"},{"location":"running/","title":"Running","text":""},{"location":"running/#using-go-generate-recommended","title":"Using <code>go generate</code> recommended","text":"<p><code>go generate</code> is often preferred as it give you more targeted generation of specific interfaces. Use <code>generate</code> as a directive above the interface you want to generate a mock for.</p> Go<pre><code>package example_project\n//go:generate mockery --name Root\ntype Root interface {\nFoobar(s string) error\n}\n</code></pre> <p>Then simply:</p> Bash<pre><code>$ go generate      09 Feb 23 22:55 CST INF Starting mockery dry-run=false version=v2.18.0\n09 Feb 23 22:55 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.18.0\n09 Feb 23 22:55 CST INF Walking dry-run=false version=v2.18.0\n09 Feb 23 22:55 CST INF Generating mock dry-run=false interface=Root qualified-name=github.com/vektra/mockery/v2/pkg/fixtures/example_project version=v2.18.0\n</code></pre>"},{"location":"running/#for-all-interfaces-in-project","title":"For all interfaces in project","text":"<p>If you provide <code>all: True</code>, you can generate mocks for the entire project. This is not recommended for larger projects as it can take a large amount of time parsing packages to generate mocks that you might never use.</p> Bash<pre><code>$ mockery\n09 Feb 23 22:47 CST INF Starting mockery dry-run=false version=v2.18.0\n09 Feb 23 22:47 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.18.0\n09 Feb 23 22:47 CST INF Walking dry-run=false version=v2.18.0\n09 Feb 23 22:47 CST INF Generating mock dry-run=false interface=A qualified-name=github.com/vektra/mockery/v2/pkg/fixtures version=v2.18.0\n</code></pre> <p>Note<p>Note that in some cases, using <code>//go:generate</code> may turn out to be slower than running for entire packages. <code>go:generate</code> calls mockery once for each <code>generate</code> directive, which means that mockery may need to parse the package multiple times, which is wasteful. Good judgement is recommended when determining the best option for your own project.</p> </p> <p>Note<p>For mockery to correctly generate mocks, the command has to be run on a module (i.e. your project has to have a go.mod file)</p> </p>"}]}